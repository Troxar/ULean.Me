Практика «Геометрия-1»

Какое же наследование без геометрии!
Скачайте проект Inheritance.Geometry и изучите файл Virtual\VirtualTask.cs. Проблема этого подхода в том, что каждый раз при добавлении нового типа тела придется менять метод в базовом классе, из-за чего код в последствии будет разрастаться и становиться все более сложным, вдобавок компилятор не способен определить, добавили ли мы необходимые вычисления в метод, и помочь нам отловить ошибку на этапе компиляции.
Предположим вы знаете, что в планах добавить ещё много новых геометрических примитивов. В этом случае разумно сделать методы ContainsPoint и GetBoundingBox абстрактными и переопределить их в классах Ball, RectangularCuboid, Cylinder и CompoundBody.
Сделайте это! Метод ContainsPoint уже реализован внутри класса Body, вам остается лишь переместить необходимые участки кода в конкретные классы фигур. Метод GetBoundingBox нужно будет реализовать с нуля. Он должен возвращать минимальный ограничивающий прямоугольный параллелепипед (RectangularCuboid), то есть такой, который полностью содержит в себе фигуру.
После такого рефакторинга код должен стать проще. В частности в финальном решении не должно остаться ни одного if-а.

Практика «Геометрия-2»

Давайте теперь предположим, что в предыдущей задаче новых геометрических примитивов добавлять мы не собираемся. Зато собираемся добавлять новые методы для работы с уже имеющимися — они могут вычислять минимальный ограничивающий прямоугольный параллелепипед, применять преобразования к фигурам или делать какие-либо другие операции: рассчитывать площадь поверхности, рассчитывать точку пересечения объекта с прямой и т.д.
В этом случае часто используется шаблон Visitor. Изучите этот шаблон по википедии.
Работайте в том же проекте Inheritance.Geometry, в файле Visitor\VisitorTask.cs.

IVisitor
Определите интерфейс IVisitor и реализуйте его в двух классах:
-	BoundingBoxVisitor, вычисляющий минимальный ограничивающий прямоугольный параллелепипед. Для реализации этого класса можно воспользоваться ранее написанным методом GetBoundingBox из прошлой практики.
-	BoxifyVisitor, заменяющий все тела, кроме CompoundBody, на их ограничивающие прямоугольные параллелепипеды. Этот класс придется создать с нуля. Диаграмма ниже объясняет ожидаемое поведение этого класса:
<FigureDiagram.png>

Body.Accept
В класс Body добавьте абстрактный метод Accept принимающий в качестве аргумента IVisitor.
Согласно шаблону Visitor этот метод будет использоваться, чтобы выполнять над фигурами разные операции, возможно даже такие, которые были не известны на момент создания иерархии фигур.

Самопроверка
Автоматизированные тесты проверяют лишь базовые требования. Проверить, что вы всё сделали правильно можно самостоятельно так:
В реализациях Visitor не должно быть ни одного приведения типов и ни одного if-а. Именно этой простотой решение с Visitor-ом лучше исходного с длинным if-else.
Работа с каждой фигурой должна оказаться в отдельном методе. А значит даже если добавится новая фигура, будет меньше возможностей случайно внести ошибку в обработку старых фигур.
Компилятор должен контролировать, что вы не забыли обработать ни одну из фигур: если вы забудете написать один из методов, программа даже не скомпилируется.
В интерфейсе IVisitor, в классе Body и всех его подклассах не должно быть никакого упоминания о прямоугольных параллелепипедах, замен фигур на них или конкретных классов Visitor-ов. А значит при добавлении новых расчетов, эти классы не нужно будет модифицировать.
Для добавления нового метода работы с фигурами, должно быть достаточно добавить новый класс Visitor-а.