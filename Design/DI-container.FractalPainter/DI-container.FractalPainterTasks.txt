Практика «Fractal Painter. DIP»

Перед вами программа, которая умеет рисовать фракталы с заданными настройками. Также можно задавать дополнительные настройки размера изображения и цвета отрисовки (пока что цвет отрисовки можно менять только у кривой Коха). Рекомендуем изучить сам проект и принцип его работы. Это в будущем позволит вам лучше понять, как внедрение DI-контейнера упрощает развитие программы. Начните изучение с файла App\Program.cs. В файлах App\ActionsTask.cs и App\DIContainerTask.cs специально собраны все необходимые классы для выполнения задания. В реальном проекте, конечно, стоило бы каждый класс поместить в собственный файл.
DI-контейнер — очень мощный инструмент в больших проектах, но чтобы приступить к его внедрению, для начала необходимо сделать небольшой рефакторинг проекта в соответствии с Dependency Inversion Principle (DIP). Работайте в файле App\ActionsTask.cs. Вам необходимо отрефакторить все классы, унаследованные от IUiAction, так чтобы в них перестал использоваться класс Services (находящийся в файле DIContainerTask.cs), а все необходимые для работы зависимости принимались через единственный конструктор и хранились в private-полях. Обращения к классу Services должны переместится в конструктор без параметров класса MainForm.

Практика «Fractal Painter. DI-container»

При решении данной практики не бойтесь раскрывать подсказки, если возникли какие-либо трудности. В случае успешного выполнения пункта, их так же рекомендуется раскрывать, чтобы сверить ваше решение с образцом.
Продолжайте в том же проекте. Теперь, когда все базовые приготовления сделаны, приступим к внедрению DI-контейнера:
1.	Исправляем MainForm:
	-	В классе DIContainerTask переделайте метод GetMainForm так, чтобы объект класса MainForm создавался контейнером.
	-	Произведите биндинг всех классов унаследованных от IUiAction (Искать в ActionsTask.cs и DIContainerTask.cs). А все зависимости для инициализации Action-объектов временно забиндите на обращение к классу Services через метод ToConstant. Все биндинги должны быть в методе ConfigureContainer.
	-	Удалите из класса MainForm конструктор без параметров и так же произведите биндинг всех необходимых для инициализации аргументов.
	На данном этапе программа должна корректно работать. Как вы можете видеть контейнер самостоятельно создает все необходимые зависимости при создании MainForm и уже сейчас становится видно, как программа становится более простой и гибкой. Но не всегда все идет так гладко, как хотелось бы.
	Подсказки:
	-	Классы унаследованные от IUiAction можно забиндить так: container.Bind<IInterface>().To<Class>();
	-	Необходимые зависимости можно забиндить так: container.Bind<IInterface>().ToConstant(Services.Get...());
2. Исправляем KochFractalAction:
	-	Отрефакторите класс KochFractalAction, также как в первой практике.
	-	Изучите KochFractalAction и поймите, что на самом деле IImageHolder и Pallette ему не нужны. Измените его так, чтобы он принимал только KochPainter.
	-	После наших действий программа работает некорректно. Подумайте из-за чего это может и попробуйте решить проблему.
	-	Убедитесь, что всё ещё работает.
	Подсказки:
	-	Сложность в том, что при инициализации MainForm необходимо перед этим создать KochFractalAction, а для него необходим KochPainter, а KochPainter в конструкторе обращается к IImageHolder, который еще не инициализирован, а инициализация происходит в конструкторе MainForm. Т.е. получается такая картина: MainForm → KochFractalAction → KochPainter → IImageHolder. Если разобраться, то станет ясно, что классу KochFractalAction KochPainter необходим лишь во время выполнения метода Perform. Подумайте, как сделать так, чтобы он создавался немного позже.
	-	Чтобы разорвать этот круг, необходимо использовать класс Lazy, при этом очень важно в конструкторе не производить обращение к Value, иначе круг снова сомкнется.
3.	Исправляем DragonFractalAction:
	-	Избавьтесь от использования класса Services в DragonFractalAction.
	-	Убедитесь, что все работает.
4.	Ребиндим IImageHolder, PictureBoxImageHolder и Palette:
	-	Перебиндите IImageHolder, PictureBoxImageHolder и Palette, так чтобы контейнер их создавал сам не обращаясь к классу Services.
	-	Убедитесь, что дракон рисуется, а палитра изменяет цвет прорисовки кривой Коха.
	Подсказки:
	-	IImageHolder, PictureBoxImageHolder и Palette должны биндиться в единственном экземпляре.
	-	Пример биндинга в единственном экземпляре: container.Bind<IInterface>.To<Class>().InSingletonScope();
	-	Биндинг IImageHolder и PictureBoxImageHolder должен указывать на один и тот же объект PictureBoxImageHolder.
	Пример такого биндинга: container.Bind<IInterface, SomeClass>().To<SomeClass>();
5.1	Улучшаем DragonFractalAction:
	-	Давайте также сделаем более гибким DragonFractalAction и будем принимать все необходимые зависимости через конструктор. Дополнительное ограничение — нельзя менять публичный интерфейс DragonPainter. Особенность в том, что одна из зависимостей DragonPainter — DragonSettings оказывается известной только в процессе работы экшена. Из-за этого вы не можете просить инжектировать в конструктор уже готовый Painter. Вместо этого инжектируйте фабрику DragonPainter-ов. Интерфейс фабрики назовите IDragonPainterFactory, настройте его так чтобы, контейнер сам сгенерировал класс реализующий интерфейс фабрики.
	-	Если вы все сделали правильно, то IImageHolder теперь нам больше не нужен и от него можно избавиться. Сделайте это.
	Подсказки:
	-	Создайте интерфейс для фабрики. У него должен быть один метод, принимающий аргументы, необходимые для создания DragonPainter, значения которых определяются только во время выполнения, и возвращающий DragonPainter. После этого в коде DragonAction можно получить в конструктор объект этого интерфейса и использовать его метод для создания зависимости. Реализовывать интерфейс фабрики не нужно —— это сделает контейнер.
	-	Пример объявления метода в интерфейсе фабрики: DragonPainter CreateDragonPainter(...)
	-	В контейнере есть договоренность - имена параметров метода в фабрике должны совпадать с именами параметров конструктора создаваемой сущности.
	-	Необязательно в параметры метода фабрики принимать все необходимые аргументы. Если какие-то аргументы можно достать из контейнера, например в нашем случае это IImageHolder, то фабрика сама сделает это, даже если они не были переданы в метод.
	-	Не забудьте забиндить особым образом фабрику.
	-	Пример биндинга фабрики: container.Bind<IFactory>().ToFactory();
5.2	Улучшаем DragonFractalAction (Необязательно):
	-	Для создания DragonPainter-а можно также использовать Func-фабрику. Закомментируйте в конструкторе предыдущую фабрику и инжектируйте Func-фабрику в DragonFractalAction.
	(!) Интерфейс фабрики и её биндинг необходимо оставить, т.к. это проверяется в тестах.
	-	Убедитесь, что все работает.
	Подсказки:
	-	Func-фабрика идентична обычной фабрике. Отличие заключается лишь в том, что вместо определения интерфейса и последующего принятие объекта интерфейса через конструктор, мы просто сразу принимаем Func-объект. Это очень удобно тем, что нам не надо ничего биндить и определять интерфейс фабрики, контейнер сам поймет, что требуется Func-фабрика.
	-	Пример Func-фабрики принимаемой в конструктор: Func<Some, Necessary, Args, NecessaryObject> CreateNecessaryObject
	-	В Func-фабрику так же можно не передавать все необходимые аргументы, а можно ограничиться лишь теми, которые нельзя достать из контейнера.
6.	Улучшаем DragonPainter:
	-	Переведите DragonPainter на использование цветов палитры, как это сделано в KochPainter
	-	Убедитесь, что экшен настройки палитры работает как надо
	Если вы всё сделали правильно, то для добавления зависимости вам не пришлось править код работы с контейнером вообще. Магия!
	Подсказки:
	-	Чтобы заменить зависимости придется использовать класс SolidBrush.
	-	Класс SolidBrush реализует интерфейс IDisposable, а значит необходимо использовать using при его внедрении.
7.	Избавляемся от зависимостей класса Services:
	-	Избавиться от обращений к классу Services при создании AppSettings и ImageSettings. Используйте ToMethod, чтобы доставать нужные зависимости из контейнера: ToMethod(context => context.Kernel.Get<TService>() ... )
	-	Убедитесь, что окно настройки размера изображения работают. Фрактал и кривая Коха должны адаптироваться под изменения изображения и не выходить за рамки в случае маленьких размеров.
	Подсказки:
	-	Чтобы создать SettingsManager и при этом не нарушить гибкость программы, необходимо обратиться к ядру контейнера через ToMethod и запросить создать SettingsManager. Так в будущем это нам с легкостью позволит при необходимости поменять SettingsManager путем изменения одной строчки биндинга, при этом целостность программы не нарушится.
	-	Пример обращения к ядру: *.ToMethod(c => c.Kernel.Get<SomeObject>();
	-	Чтобы контейнер мог создать SettingsManager, необходимо забиндить аргументы, которые необходимы для его создания.
	-	ImageSettings нужно получать из AppSettings, который мы получаем из SettingsManager-а. Здесь вам снова поможет ToMethod.
	-	Чтобы не нарушить гибкость программы, запросите у ядра AppSettings и верните переданные настройки.
	-	AppSettings и ImageSettings должны быть забинджены в единственном экземпляре.
	-	Чтобы кривая Коха адаптировалась под размеры изображения, при биндинге аргументов SettingsManager, необходимо явно указать контейнеру, что эти объекты используются только при создании SettingsManager-а. В этом вам поможет команда *.WhenInjectedInto<SomeClass>();
