Практика «Fractal Painter. DIP»

Перед вами программа, которая умеет рисовать фракталы с заданными настройками. Также можно задавать дополнительные настройки размера изображения и цвета отрисовки (пока что цвет отрисовки можно менять только у кривой Коха). Рекомендуем изучить сам проект и принцип его работы. Это в будущем позволит вам лучше понять, как внедрение DI-контейнера упрощает развитие программы. Начните изучение с файла App\Program.cs. В файлах App\ActionsTask.cs и App\DIContainerTask.cs специально собраны все необходимые классы для выполнения задания. В реальном проекте, конечно, стоило бы каждый класс поместить в собственный файл.
DI-контейнер — очень мощный инструмент в больших проектах, но чтобы приступить к его внедрению, для начала необходимо сделать небольшой рефакторинг проекта в соответствии с Dependency Inversion Principle (DIP). Работайте в файле App\ActionsTask.cs. Вам необходимо отрефакторить все классы, унаследованные от IUiAction, так чтобы в них перестал использоваться класс Services (находящийся в файле DIContainerTask.cs), а все необходимые для работы зависимости принимались через единственный конструктор и хранились в private-полях. Обращения к классу Services должны переместится в конструктор без параметров класса MainForm.

Практика «Fractal Painter. DI-container»

При решении данной практики не бойтесь раскрывать подсказки, если возникли какие-либо трудности. В случае успешного выполнения пункта, их так же рекомендуется раскрывать, чтобы сверить ваше решение с образцом.
Продолжайте в том же проекте. Теперь, когда все базовые приготовления сделаны, приступим к внедрению DI-контейнера:
1.	Исправляем MainForm:
	-	В классе DIContainerTask переделайте метод GetMainForm так, чтобы объект класса MainForm создавался контейнером.
	-	Произведите биндинг всех классов унаследованных от IUiAction (Искать в ActionsTask.cs и DIContainerTask.cs). А все зависимости для инициализации Action-объектов временно забиндите на обращение к классу Services через метод ToConstant. Все биндинги должны быть в методе ConfigureContainer.
	-	Удалите из класса MainForm конструктор без параметров и так же произведите биндинг всех необходимых для инициализации аргументов.
	На данном этапе программа должна корректно работать. Как вы можете видеть контейнер самостоятельно создает все необходимые зависимости при создании MainForm и уже сейчас становится видно, как программа становится более простой и гибкой. Но не всегда все идет так гладко, как хотелось бы.
	Подсказки:
	-	Классы унаследованные от IUiAction можно забиндить так: container.Bind<IInterface>().To<Class>();
	-	Необходимые зависимости можно забиндить так: container.Bind<IInterface>().ToConstant(Services.Get...());
2. Исправляем KochFractalAction:
	-	Отрефакторите класс KochFractalAction, также как в первой практике.
	-	Изучите KochFractalAction и поймите, что на самом деле IImageHolder и Pallette ему не нужны. Измените его так, чтобы он принимал только KochPainter.
	-	После наших действий программа работает некорректно. Подумайте из-за чего это может и попробуйте решить проблему.
	-	Убедитесь, что всё ещё работает.
	Подсказки:
	-	Сложность в том, что при инициализации MainForm необходимо перед этим создать KochFractalAction, а для него необходим KochPainter, а KochPainter в конструкторе обращается к IImageHolder, который еще не инициализирован, а инициализация происходит в конструкторе MainForm. Т.е. получается такая картина: MainForm → KochFractalAction → KochPainter → IImageHolder. Если разобраться, то станет ясно, что классу KochFractalAction KochPainter необходим лишь во время выполнения метода Perform. Подумайте, как сделать так, чтобы он создавался немного позже.
	-	Чтобы разорвать этот круг, необходимо использовать класс Lazy, при этом очень важно в конструкторе не производить обращение к Value, иначе круг снова сомкнется.
